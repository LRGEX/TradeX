pythonimport os
from dotenv import load_dotenv

load_dotenv()

class Settings:
    INSIGHTSENTRY_API_KEY: str = os.getenv("INSIGHTSENTRY_API_KEY", "")
    INSIGHTSENTRY_REST_URL: str = "https://api.insightsentry.com/v2"
    INSIGHTSENTRY_WS_URL: str = "wss://realtime.insightsentry.com/live"
    
    # Pro plan limits
    REST_RATE_LIMIT: int = 25        # per minute
    WS_SUBSCRIPTIONS: int = 5        # concurrent
    WS_MESSAGES_PER_5MIN: int = 300  # rate limit

settings = Settings()
1.3 Create services/insightsentry.py (REST Client)
python"""InsightSentry REST client for historical data."""
import time
import httpx
from collections import deque
from config import settings


class RateLimiter:
    """
    Rate limiter for InsightSentry Pro plan.
    - 25 requests per minute
    - 50,000 requests per month
    """
    def __init__(self, max_requests: int = 25, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests = deque()
    
    def can_proceed(self) -> bool:
        now = time.time()
        while self.requests and self.requests[0] < now - self.window_seconds:
            self.requests.popleft()
        return len(self.requests) < self.max_requests
    
    def record(self):
        self.requests.append(time.time())
    
    def wait_time(self) -> float:
        if self.can_proceed():
            return 0
        return self.requests[0] + self.window_seconds - time.time()


# Interval mapping: UI label -> (bar_type, bar_interval)
INTERVAL_MAP = {
    "1m": ("minute", 1),
    "5m": ("minute", 5),
    "15m": ("minute", 15),
    "30m": ("minute", 30),  # Added 30 minute
    "1h": ("hour", 1),
    "4h": ("hour", 4),
    "1d": ("day", 1),
    "1w": ("week", 1),
    "1M": ("month", 1),
}


class InsightSentryREST:
    """
    InsightSentry REST API client.
    
    Docs: https://insightsentry.com/docs
    Endpoint: GET /v2/symbols/:symbol/series
    """
    def __init__(self):
        self.api_key = settings.INSIGHTSENTRY_API_KEY
        self.base_url = settings.INSIGHTSENTRY_REST_URL
        self.rate_limiter = RateLimiter(max_requests=25)
    
    async def get_candles(
        self,
        symbol: str,
        exchange: str,
        interval: str = "5m",
        limit: int = 1000
    ) -> list:
        """
        Fetch historical OHLCV candles.
        
        Args:
            symbol: e.g., "AAPL", "BTCUSDT"
            exchange: e.g., "NASDAQ", "BINANCE"
            interval: "1m", "5m", "15m", "30m", "1h", "4h", "1d", "1w", "1M"
            limit: Number of bars (max 20,000 for Pro plan)
        
        Returns:
            List of candle dicts with time, open, high, low, close, volume
        """
        if not self.rate_limiter.can_proceed():
            wait = self.rate_limiter.wait_time()
            raise Exception(f"Rate limited. Wait {wait:.1f}s")
        
        bar_type, bar_interval = INTERVAL_MAP.get(interval, ("minute", 5))
        
        # InsightSentry symbol format: EXCHANGE:SYMBOL
        is_symbol = f"{exchange}:{symbol}"
        url = f"{self.base_url}/symbols/{is_symbol}/series"
        
        async with httpx.AsyncClient(timeout=30) as client:
            response = await client.get(
                url,
                headers={"Authorization": f"Bearer {self.api_key}"},
                params={
                    "bar_type": bar_type,
                    "bar_interval": bar_interval,
                    "limit": limit,
                    "extended": "true"  # Include pre/post market
                }
            )
            self.rate_limiter.record()
            response.raise_for_status()
            data = response.json()
        
        # Format for Lightweight Charts (time as Unix timestamp)
        candles = []
        for bar in data.get("series", []):
            candles.append({
                "time": int(bar["time"]),
                "open": float(bar["open"]),
                "high": float(bar["high"]),
                "low": float(bar["low"]),
                "close": float(bar["close"]),
                "volume": float(bar.get("volume", 0))
            })
        return candles


rest_client = InsightSentryREST()
1.4 Create services/insightsentry_ws.py (WebSocket Client)
python"""
InsightSentry WebSocket client for real-time data.

Docs: https://insightsentry.com/docs/ws
Endpoint: wss://realtime.insightsentry.com/live

Key behaviors:
- Send subscription in onOpen (for auto-reconnect)
- New subscription REPLACES all previous subscriptions
- Send ping every 20-30 seconds (max 1 per 15s)
- Server sends heartbeat {"server_time": ...} every ~10s
- Rate limit: 300 outbound messages per 5 minutes
"""
import json
import asyncio
import websockets
from typing import Callable, Optional
from config import settings


# Interval mapping (same as REST client)
INTERVAL_MAP = {
    "1m": ("minute", 1),
    "5m": ("minute", 5),
    "15m": ("minute", 15),
    "30m": ("minute", 30),
    "1h": ("hour", 1),
    "4h": ("hour", 4),
    "1d": ("day", 1),
    "1w": ("week", 1),
    "1M": ("month", 1),
}


class InsightSentryWebSocket:
    def __init__(self):
        self.api_key = settings.INSIGHTSENTRY_API_KEY
        self.ws_url = settings.INSIGHTSENTRY_WS_URL
        self.ws: Optional[websockets.WebSocketClientProtocol] = None
        self.running = False
        self._ping_task: Optional[asyncio.Task] = None
    
    async def connect(self):
        """Establish WebSocket connection."""
        self.ws = await websockets.connect(
            self.ws_url,
            ping_interval=None,  # We handle ping manually
            ping_timeout=None
        )
        self.running = True
        
        # Start ping task (keep-alive)
        self._ping_task = asyncio.create_task(self._ping_loop())
    
    async def _ping_loop(self):
        """Send ping every 20 seconds to keep connection alive."""
        while self.running:
            try:
                await asyncio.sleep(20)
                if self.ws and self.running:
                    await self.ws.send("ping")
            except Exception:
                break
    
    async def subscribe(
        self,
        symbol: str,
        exchange: str,
        interval: str,
        on_message: Callable
    ):
        """
        Subscribe to real-time data for a symbol.
        
        Note: Each subscribe call REPLACES all previous subscriptions.
        Pro plan allows 2 concurrent subscriptions.
        """
        if not self.ws:
            await self.connect()
        
        bar_type, bar_interval = INTERVAL_MAP.get(interval, ("minute", 5))
        is_symbol = f"{exchange}:{symbol}"
        
        # Subscription message
        # Note: For direct website subscribers, use same API key for REST and WS
        subscribe_msg = {
            "api_key": self.api_key,
            "subscriptions": [{
                "code": is_symbol,
                "type": "series",
                "bar_type": bar_type,
                "bar_interval": bar_interval,
                "extended": True,
                "max_dp": 1000  # Get last 1000 bars on connect (Pro limit)
            }]
        }
        
        await self.ws.send(json.dumps(subscribe_msg))
        
        # Listen for messages
        try:
            async for message in self.ws:
                if not self.running:
                    break
                
                # Filter pong and heartbeat
                if message == "pong":
                    continue
                
                try:
                    data = json.loads(message)
                    
                    # Skip server heartbeat messages
                    if "server_time" in data:
                        continue
                    
                    # Skip error messages (log them)
                    if "message" in data and "code" not in data:
                        print(f"InsightSentry message: {data['message']}")
                        continue
                    
                    # Forward candle data
                    await on_message(data)
                    
                except json.JSONDecodeError:
                    continue
                    
        except websockets.exceptions.ConnectionClosed:
            self.running = False
    
    async def change_subscription(
        self,
        symbol: str,
        exchange: str,
        interval: str
    ):
        """
        Change to a new symbol/interval.
        This REPLACES all existing subscriptions.
        """
        if not self.ws:
            return
        
        bar_type, bar_interval = INTERVAL_MAP.get(interval, ("minute", 5))
        is_symbol = f"{exchange}:{symbol}"
        
        subscribe_msg = {
            "api_key": self.api_key,
            "subscriptions": [{
                "code": is_symbol,
                "type": "series",
                "bar_type": bar_type,
                "bar_interval": bar_interval,
                "extended": True,
                "max_dp": 1000
            }]
        }
        
        await self.ws.send(json.dumps(subscribe_msg))
    
    async def disconnect(self):
        """Close WebSocket connection."""
        self.running = False
        
        if self._ping_task:
            self._ping_task.cancel()
            try:
                await self._ping_task
            except asyncio.CancelledError:
                pass
        
        if self.ws:
            await self.ws.close()
            self.ws = None
1.5 Create main.py
python"""FastAPI backend with REST + WebSocket endpoints."""
import json
import asyncio
from fastapi import FastAPI, HTTPException, Query, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from services.insightsentry import rest_client
from services.insightsentry_ws import InsightSentryWebSocket

app = FastAPI(title="Trading Platform - Stage 1")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


@app.get("/api/candles")
async def get_candles(
    symbol: str = Query(...),
    exchange: str = Query("NASDAQ"),
    interval: str = Query("5m"),
    limit: int = Query(1000, ge=1, le=20000)
):
    """Fetch historical OHLCV candles."""
    try:
        candles = await rest_client.get_candles(symbol, exchange, interval, limit)
        return {"symbol": symbol, "exchange": exchange, "interval": interval, "data": candles}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.websocket("/ws/live")
async def websocket_endpoint(
    websocket: WebSocket,
    symbol: str = Query(...),
    exchange: str = Query("NASDAQ"),
    interval: str = Query("5m")
):
    """
    WebSocket endpoint for real-time data.
    
    Flow:
    1. Accept connection
    2. Fetch historical data and send
    3. Connect to InsightSentry WebSocket
    4. Stream real-time updates to client
    """
    await websocket.accept()
    
    # Create dedicated WS client for this connection
    is_ws = InsightSentryWebSocket()
    current_symbol = symbol
    current_exchange = exchange
    current_interval = interval
    
    async def send_to_client(data):
        """Forward InsightSentry data to frontend."""
        try:
            # Format the tick data
            if "series" in data:
                for bar in data["series"]:
                    candle = {
                        "type": "candle",
                        "data": {
                            "time": int(bar["time"]),
                            "open": float(bar["open"]),
                            "high": float(bar["high"]),
                            "low": float(bar["low"]),
                            "close": float(bar["close"]),
                            "volume": float(bar.get("volume", 0))
                        }
                    }
                    await websocket.send_json(candle)
        except Exception as e:
            print(f"Error sending to client: {e}")
    
    try:
        # 1. Send historical data first
        candles = await rest_client.get_candles(
            current_symbol, current_exchange, current_interval, 1000
        )
        await websocket.send_json({
            "type": "history",
            "symbol": current_symbol,
            "exchange": current_exchange,
            "interval": current_interval,
            "data": candles
        })
        
        # 2. Start real-time stream in background
        stream_task = asyncio.create_task(
            is_ws.subscribe(current_symbol, current_exchange, current_interval, send_to_client)
        )
        
        # 3. Listen for client messages (symbol changes, etc.)
        while True:
            try:
                msg = await asyncio.wait_for(websocket.receive_json(), timeout=0.1)
                
                if msg.get("action") == "subscribe":
                    # Change symbol
                    new_symbol = msg.get("symbol", current_symbol)
                    new_exchange = msg.get("exchange", current_exchange)
                    new_interval = msg.get("interval", current_interval)
                    
                    # Unsubscribe from old
                    await is_ws.unsubscribe(current_symbol, current_exchange)
                    
                    # Update current
                    current_symbol = new_symbol
                    current_exchange = new_exchange
                    current_interval = new_interval
                    
                    # Send new history
                    candles = await rest_client.get_candles(
                        current_symbol, current_exchange, current_interval, 1000
                    )
                    await websocket.send_json({
                        "type": "history",
                        "symbol": current_symbol,
                        "exchange": current_exchange,
                        "interval": current_interval,
                        "data": candles
                    })
                    
                    # Cancel old stream, start new
                    stream_task.cancel()
                    stream_task = asyncio.create_task(
                        is_ws.subscribe(current_symbol, current_exchange, current_interval, send_to_client)
                    )
            
            except asyncio.TimeoutError:
                continue
            except WebSocketDisconnect:
                break
    
    except WebSocketDisconnect:
        pass
    finally:
        await is_ws.disconnect()


@app.get("/api/health")
async def health():
    return {"status": "ok"}